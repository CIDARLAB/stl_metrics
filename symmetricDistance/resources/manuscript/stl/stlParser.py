# Generated from /home/cristi/Dropbox/work/workspace_linux_precision5520/python-stl/stl/stl.g4 by ANTLR 4.7.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


'''
 Copyright (C) 2015-2018 Cristian Ioan Vasile <cvasile@mit.edu>,
                         Prashant Vaidyanathan <prash@bu.edu>,
                         Curtis Madsen <ckmadsen@bu.edu>
 Hybrid and Networked Systems (HyNeSs) Group, BU Robotics Lab, Boston University
 Cross Disciplinary Integration for Design Automation Research (CIDAR Lab), Boston University
 See license.txt file for license information.
'''

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"$\\\4\2\t\2\4\3\t\3\4\4\t\4\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write(u"\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write(u"\2\3\2\3\2\5\2\37\n\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2")
        buf.write(u"\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\7\2")
        buf.write(u"\65\n\2\f\2\16\28\13\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write(u"\3\3\3\3\3\3\3\5\3E\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write(u"\3\3\3\7\3P\n\3\f\3\16\3S\13\3\3\4\3\4\3\4\3\4\3\4\5")
        buf.write(u"\4Z\n\4\3\4\2\4\2\4\5\2\4\6\2\7\4\2\3\3\20\20\3\2\22")
        buf.write(u"\27\3\2\30\31\3\2\32\33\3\2\34 \2h\2\36\3\2\2\2\4D\3")
        buf.write(u"\2\2\2\6Y\3\2\2\2\b\t\b\2\1\2\t\n\7\3\2\2\n\13\5\2\2")
        buf.write(u"\2\13\f\7\4\2\2\f\37\3\2\2\2\r\37\5\6\4\2\16\17\7\5\2")
        buf.write(u"\2\17\37\5\2\2\n\20\21\7\6\2\2\21\22\7\7\2\2\22\23\7")
        buf.write(u"#\2\2\23\24\7\b\2\2\24\25\7#\2\2\25\26\7\t\2\2\26\37")
        buf.write(u"\5\2\2\t\27\30\7\n\2\2\30\31\7\7\2\2\31\32\7#\2\2\32")
        buf.write(u"\33\7\b\2\2\33\34\7#\2\2\34\35\7\t\2\2\35\37\5\2\2\b")
        buf.write(u"\36\b\3\2\2\2\36\r\3\2\2\2\36\16\3\2\2\2\36\20\3\2\2")
        buf.write(u"\2\36\27\3\2\2\2\37\66\3\2\2\2 !\f\7\2\2!\"\7\13\2\2")
        buf.write(u"\"\65\5\2\2\b#$\f\6\2\2$%\7\f\2\2%\65\5\2\2\7&\'\f\5")
        buf.write(u"\2\2\'(\7\r\2\2(\65\5\2\2\6)*\f\4\2\2*+\7\16\2\2+\65")
        buf.write(u"\5\2\2\5,-\f\3\2\2-.\7\17\2\2./\7\7\2\2/\60\7#\2\2\60")
        buf.write(u"\61\7\b\2\2\61\62\7#\2\2\62\63\7\t\2\2\63\65\5\2\2\4")
        buf.write(u"\64 \3\2\2\2\64#\3\2\2\2\64&\3\2\2\2\64)\3\2\2\2\64,")
        buf.write(u"\3\2\2\2\658\3\2\2\2\66\64\3\2\2\2\66\67\3\2\2\2\67\3")
        buf.write(u"\3\2\2\28\66\3\2\2\29:\b\3\1\2:;\t\2\2\2;<\5\4\3\2<=")
        buf.write(u"\7\4\2\2=E\3\2\2\2>?\t\3\2\2?@\5\4\3\2@A\7\4\2\2AE\3")
        buf.write(u"\2\2\2BE\7#\2\2CE\7\"\2\2D9\3\2\2\2D>\3\2\2\2DB\3\2\2")
        buf.write(u"\2DC\3\2\2\2EQ\3\2\2\2FG\f\b\2\2GH\7\21\2\2HP\5\4\3\t")
        buf.write(u"IJ\f\6\2\2JK\t\4\2\2KP\5\4\3\7LM\f\5\2\2MN\t\5\2\2NP")
        buf.write(u"\5\4\3\6OF\3\2\2\2OI\3\2\2\2OL\3\2\2\2PS\3\2\2\2QO\3")
        buf.write(u"\2\2\2QR\3\2\2\2R\5\3\2\2\2SQ\3\2\2\2TU\5\4\3\2UV\t\6")
        buf.write(u"\2\2VW\5\4\3\2WZ\3\2\2\2XZ\7!\2\2YT\3\2\2\2YX\3\2\2\2")
        buf.write(u"Z\7\3\2\2\2\t\36\64\66DOQY")
        return buf.getvalue()


class stlParser ( Parser ):

    grammarFileName = "stl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'('", u"')'", u"'!'", u"'F'", u"'['", 
                     u"','", u"']'", u"'G'", u"'=>'", u"'&&'", u"'||'", 
                     u"'>>'", u"'U'", u"'-('", u"'^'", u"'sqrt('", u"'log('", 
                     u"'ln('", u"'abs('", u"'der('", u"'int('", u"'*'", 
                     u"'/'", u"'+'", u"'-'", u"'<'", u"'<='", u"'='", u"'>='", 
                     u"'>'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"BOOLEAN", 
                      u"VARIABLE", u"RATIONAL", u"WS" ]

    RULE_stlProperty = 0
    RULE_expr = 1
    RULE_booleanExpr = 2

    ruleNames =  [ u"stlProperty", u"expr", u"booleanExpr" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    BOOLEAN=31
    VARIABLE=32
    RATIONAL=33
    WS=34

    def __init__(self, input, output=sys.stdout):
        super(stlParser, self).__init__(input, output=output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class StlPropertyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(stlParser.StlPropertyContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stlParser.RULE_stlProperty

     
        def copyFrom(self, ctx):
            super(stlParser.StlPropertyContext, self).copyFrom(ctx)


    class BooleanPredContext(StlPropertyContext):

        def __init__(self, parser, ctx): # actually a stlParser.StlPropertyContext)
            super(stlParser.BooleanPredContext, self).__init__(parser)
            self.copyFrom(ctx)

        def booleanExpr(self):
            return self.getTypedRuleContext(stlParser.BooleanExprContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterBooleanPred"):
                listener.enterBooleanPred(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBooleanPred"):
                listener.exitBooleanPred(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBooleanPred"):
                return visitor.visitBooleanPred(self)
            else:
                return visitor.visitChildren(self)


    class FormulaContext(StlPropertyContext):

        def __init__(self, parser, ctx): # actually a stlParser.StlPropertyContext)
            super(stlParser.FormulaContext, self).__init__(parser)
            self.left = None # StlPropertyContext
            self.op = None # Token
            self.child = None # StlPropertyContext
            self.low = None # Token
            self.high = None # Token
            self.right = None # StlPropertyContext
            self.copyFrom(ctx)

        def stlProperty(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(stlParser.StlPropertyContext)
            else:
                return self.getTypedRuleContext(stlParser.StlPropertyContext,i)

        def RATIONAL(self, i=None):
            if i is None:
                return self.getTokens(stlParser.RATIONAL)
            else:
                return self.getToken(stlParser.RATIONAL, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterFormula"):
                listener.enterFormula(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFormula"):
                listener.exitFormula(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitFormula"):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)


    class ParpropContext(StlPropertyContext):

        def __init__(self, parser, ctx): # actually a stlParser.StlPropertyContext)
            super(stlParser.ParpropContext, self).__init__(parser)
            self.child = None # StlPropertyContext
            self.copyFrom(ctx)

        def stlProperty(self):
            return self.getTypedRuleContext(stlParser.StlPropertyContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterParprop"):
                listener.enterParprop(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitParprop"):
                listener.exitParprop(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitParprop"):
                return visitor.visitParprop(self)
            else:
                return visitor.visitChildren(self)



    def stlProperty(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stlParser.StlPropertyContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 0
        self.enterRecursionRule(localctx, 0, self.RULE_stlProperty, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                localctx = stlParser.ParpropContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 7
                self.match(stlParser.T__0)
                self.state = 8
                localctx.child = self.stlProperty(0)
                self.state = 9
                self.match(stlParser.T__1)
                pass

            elif la_ == 2:
                localctx = stlParser.BooleanPredContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 11
                self.booleanExpr()
                pass

            elif la_ == 3:
                localctx = stlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 12
                localctx.op = self.match(stlParser.T__2)
                self.state = 13
                localctx.child = self.stlProperty(8)
                pass

            elif la_ == 4:
                localctx = stlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 14
                localctx.op = self.match(stlParser.T__3)
                self.state = 15
                self.match(stlParser.T__4)
                self.state = 16
                localctx.low = self.match(stlParser.RATIONAL)
                self.state = 17
                self.match(stlParser.T__5)
                self.state = 18
                localctx.high = self.match(stlParser.RATIONAL)
                self.state = 19
                self.match(stlParser.T__6)
                self.state = 20
                localctx.child = self.stlProperty(7)
                pass

            elif la_ == 5:
                localctx = stlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 21
                localctx.op = self.match(stlParser.T__7)
                self.state = 22
                self.match(stlParser.T__4)
                self.state = 23
                localctx.low = self.match(stlParser.RATIONAL)
                self.state = 24
                self.match(stlParser.T__5)
                self.state = 25
                localctx.high = self.match(stlParser.RATIONAL)
                self.state = 26
                self.match(stlParser.T__6)
                self.state = 27
                localctx.child = self.stlProperty(6)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 52
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 50
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                    if la_ == 1:
                        localctx = stlParser.FormulaContext(self, stlParser.StlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_stlProperty)
                        self.state = 30
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 31
                        localctx.op = self.match(stlParser.T__8)
                        self.state = 32
                        localctx.right = self.stlProperty(6)
                        pass

                    elif la_ == 2:
                        localctx = stlParser.FormulaContext(self, stlParser.StlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_stlProperty)
                        self.state = 33
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 34
                        localctx.op = self.match(stlParser.T__9)
                        self.state = 35
                        localctx.right = self.stlProperty(5)
                        pass

                    elif la_ == 3:
                        localctx = stlParser.FormulaContext(self, stlParser.StlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_stlProperty)
                        self.state = 36
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 37
                        localctx.op = self.match(stlParser.T__10)
                        self.state = 38
                        localctx.right = self.stlProperty(4)
                        pass

                    elif la_ == 4:
                        localctx = stlParser.FormulaContext(self, stlParser.StlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_stlProperty)
                        self.state = 39
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 40
                        localctx.op = self.match(stlParser.T__11)
                        self.state = 41
                        localctx.right = self.stlProperty(3)
                        pass

                    elif la_ == 5:
                        localctx = stlParser.FormulaContext(self, stlParser.StlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_stlProperty)
                        self.state = 42
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 43
                        localctx.op = self.match(stlParser.T__12)
                        self.state = 44
                        self.match(stlParser.T__4)
                        self.state = 45
                        localctx.low = self.match(stlParser.RATIONAL)
                        self.state = 46
                        self.match(stlParser.T__5)
                        self.state = 47
                        localctx.high = self.match(stlParser.RATIONAL)
                        self.state = 48
                        self.match(stlParser.T__6)
                        self.state = 49
                        localctx.right = self.stlProperty(2)
                        pass

             
                self.state = 54
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(stlParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(stlParser.ExprContext)
            else:
                return self.getTypedRuleContext(stlParser.ExprContext,i)


        def RATIONAL(self):
            return self.getToken(stlParser.RATIONAL, 0)

        def VARIABLE(self):
            return self.getToken(stlParser.VARIABLE, 0)

        def getRuleIndex(self):
            return stlParser.RULE_expr

        def enterRule(self, listener):
            if hasattr(listener, "enterExpr"):
                listener.enterExpr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpr"):
                listener.exitExpr(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpr"):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = stlParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stlParser.T__0, stlParser.T__13]:
                self.state = 56
                _la = self._input.LA(1)
                if not(_la==stlParser.T__0 or _la==stlParser.T__13):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 57
                self.expr(0)
                self.state = 58
                self.match(stlParser.T__1)
                pass
            elif token in [stlParser.T__15, stlParser.T__16, stlParser.T__17, stlParser.T__18, stlParser.T__19, stlParser.T__20]:
                self.state = 60
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stlParser.T__15) | (1 << stlParser.T__16) | (1 << stlParser.T__17) | (1 << stlParser.T__18) | (1 << stlParser.T__19) | (1 << stlParser.T__20))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 61
                self.expr(0)
                self.state = 62
                self.match(stlParser.T__1)
                pass
            elif token in [stlParser.RATIONAL]:
                self.state = 64
                self.match(stlParser.RATIONAL)
                pass
            elif token in [stlParser.VARIABLE]:
                self.state = 65
                self.match(stlParser.VARIABLE)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 79
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 77
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                    if la_ == 1:
                        localctx = stlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 68
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 69
                        self.match(stlParser.T__14)
                        self.state = 70
                        self.expr(7)
                        pass

                    elif la_ == 2:
                        localctx = stlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 71
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 72
                        _la = self._input.LA(1)
                        if not(_la==stlParser.T__21 or _la==stlParser.T__22):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 73
                        self.expr(5)
                        pass

                    elif la_ == 3:
                        localctx = stlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 74
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 75
                        _la = self._input.LA(1)
                        if not(_la==stlParser.T__23 or _la==stlParser.T__24):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 76
                        self.expr(4)
                        pass

             
                self.state = 81
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class BooleanExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(stlParser.BooleanExprContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ExprContext
            self.op = None # Token
            self.right = None # ExprContext

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(stlParser.ExprContext)
            else:
                return self.getTypedRuleContext(stlParser.ExprContext,i)


        def BOOLEAN(self):
            return self.getToken(stlParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return stlParser.RULE_booleanExpr

        def enterRule(self, listener):
            if hasattr(listener, "enterBooleanExpr"):
                listener.enterBooleanExpr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBooleanExpr"):
                listener.exitBooleanExpr(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBooleanExpr"):
                return visitor.visitBooleanExpr(self)
            else:
                return visitor.visitChildren(self)




    def booleanExpr(self):

        localctx = stlParser.BooleanExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_booleanExpr)
        self._la = 0 # Token type
        try:
            self.state = 87
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stlParser.T__0, stlParser.T__13, stlParser.T__15, stlParser.T__16, stlParser.T__17, stlParser.T__18, stlParser.T__19, stlParser.T__20, stlParser.VARIABLE, stlParser.RATIONAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                localctx.left = self.expr(0)
                self.state = 83
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stlParser.T__25) | (1 << stlParser.T__26) | (1 << stlParser.T__27) | (1 << stlParser.T__28) | (1 << stlParser.T__29))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 84
                localctx.right = self.expr(0)
                pass
            elif token in [stlParser.BOOLEAN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 86
                localctx.op = self.match(stlParser.BOOLEAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx, ruleIndex, predIndex):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[0] = self.stlProperty_sempred
        self._predicates[1] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def stlProperty_sempred(self, localctx, predIndex):
            if predIndex == 0:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

    def expr_sempred(self, localctx, predIndex):
            if predIndex == 5:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 3)
         




